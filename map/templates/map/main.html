<!doctype html>
<html>
<head>
    <title>Many Points with  leaflet WebGL</title>
    <meta charset="utf-8">

    <style>
        html, body {
            height: 100%;
            padding: 0;
            margin: 0;
            background: rgb(123, 31, 162);
            height: 100%;
            position: relative;
            
        }
        
        .axis text {
  font: 10px sans-serif;
}

.axis line,
.axis path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

        
        path {
            fill: #009688;   
        }

        #map {
            position: absolute;
            height: 100%;
            width: 100%;
            background-color: #7b1fa2;
        }
        
        #slider {
            width: 90%;
            margin-left: 5%;
            margin-right: 5%;
            margin-bottom: 20px;
            fill: #FF5252;
        }
        
        

/*        #timeline {
            position: absolute;
//            height: 100%;
            width: 100%;
            background-color: #7b1fa2;
        }*/
    </style>
</head>
<body>
    <div id="map"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css" />
    <script src="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js"></script>
    <script src="http://www.sumbera.com/gist/js/leaflet/canvas/L.CanvasOverlay.js"></script>
    <script src="http://www.sumbera.com/gist/86T.json" charset="utf-8"></script>
    <link rel="stylesheet" type="text/css" href="/static/d3.slider.css" media="screen" />
    <script src="/static/d3.slider.js"></script>

    <div id="slider"></div>
    <script>
        
        function timeToSeconds(time) {
            time = time.split(/:/);
            var newTime = parseInt(time[0]*60) + parseInt(time[1]);
            return newTime;
        }
        
        var date = new Date();
        var currentTime = date.getMinutes() + 60 * date.getSeconds();

    var slider = d3.slider().axis(true).min(0).max(currentTime).step(60);
        
    d3.select('#slider').call(slider);

    var Environment = {
        //mobile or desktop compatible event name, to be used with '.on' function
        TOUCH_DOWN_EVENT_NAME: 'mousedown touchstart',
        TOUCH_UP_EVENT_NAME: 'mouseup touchend',
        TOUCH_MOVE_EVENT_NAME: 'mousemove touchmove',
        TOUCH_DOUBLE_TAB_EVENT_NAME: 'dblclick dbltap',

        isAndroid: function() {
            return navigator.userAgent.match(/Android/i);
        },
        isBlackBerry: function() {
            return navigator.userAgent.match(/BlackBerry/i);
        },
        isIOS: function() {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i);
        },
        isOpera: function() {
            return navigator.userAgent.match(/Opera Mini/i);
        },
        isWindows: function() {
            return navigator.userAgent.match(/IEMobile/i);
        },
        isMobile: function() {
            return (Environment.isAndroid() || Environment.isBlackBerry() || Environment.isIOS() || Environment.isOpera() || Environment.isWindows());
        }
    };
function getParameterByName(name) {
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results === null ? 0 : decodeURIComponent(results[1].replace(/\+/g, " "));
}
        
            var cscale = d3.scale.linear().domain([1, 3]).range(["#ff0000", "#ff6a00", "#ffd800", "#b6ff00", "#00ffff", "#0094ff"]);//"#00FF00","#FFA500"
            var leafletMap = L.map('map').setView([getParameterByName('lat'), getParameterByName('lon')], 11);

//            L.tileLayer("http://{s}.sm.mapstack.stamen.com/(toner-lite,$fff[difference],$fff[@23],$fff[hsl-saturation@20])/{z}/{x}/{y}.png").addTo(leafletMap);
            L.tileLayer("http://{s}.sm.mapstack.stamen.com/($7b1fa2[@p],toner-lite[soft-light],$ff5252[difference@p],$ff0000[hsl-saturation@p])/{z}/{x}/{y}.png").addTo(leafletMap);

            var svg = d3.select(leafletMap.getPanes().overlayPane).append("svg");
            var g = svg.append("g").attr("class", "leaflet-zoom-hide");
        
//        var cars = d3.csv("cars.csv")
//    .get(function(error, rows) { console.log(rows); });
        
        //L.tileLayer("http://{s}.sm.mapstack.stamen.com/(toner-background,$fff[difference],$fff[@23],$fff[hsl-saturation@20],toner-lines[destination-in])/{z}/{x}/{y}.png")
//        L.tileLayer("http://{s}.sm.mapstack.stamen.com/((toner-lite,$fff[difference],$fff[@10]),$0098d7[screen@p],$00c0fa[difference@p],(mapbox-water,$002d23[source-in])[screen])/{z}/{x}/{y}.png")
  //          .addTo(leafletMap);
        
        d3.csv('/static/testDataCZ.csv', function (error, incidents) {

            function reformat(array) {
                var data = [];
                array.map(function (d, i) {
                    data.push({
                        id: i,
                        type: "Feature",
                        geometry: {
                            coordinates: [+d.longitude, +d.latitude],
                            type: "Point"
                        },
                        time: d.time                     

                    });
                });
                return data;
            }
            var geoData = { type: "FeatureCollection", features: reformat(incidents) };
            
            var numPoints = incidents.length;
            
            



            var qtree = d3.geom.quadtree(geoData.features.map(function (data, i) {
                return {
                    x: data.geometry.coordinates[0],
                    y: data.geometry.coordinates[1],
                    all: data
                };
            }
                                                         )
                                                  );


            // Find the nodes within the specified rectangle.
            function search(quadtree, x0, y0, x3, y3) {
                var pts = [];
                var subPixel = false;
                var subPts = [];
                var scale = getZoomScale();
                console.log(" scale: " + scale);
                var counter = 0;
                quadtree.visit(function (node, x1, y1, x2, y2) {
                    var p = node.point;
                    var pwidth = node.width * scale;
                    var pheight = node.height * scale;

                    // -- if this is too small rectangle only count the branch and set opacity
                    if ((pwidth * pheight) <= 1) {
                        // start collecting sub Pixel points
                        subPixel = true;
                    }
                        // -- jumped to super node large than 1 pixel
                    else {
                        // end collecting sub Pixel points
                        if (subPixel && subPts && subPts.length > 0) {

                            subPts[0].group = subPts.length;
//                            alert(subPts.length);
                            pts.push(subPts[0]); // add only one todo calculate intensity
                            counter += subPts.length - 1;
                            subPts = [];
                        }
                        subPixel = false;
                    }

                    if ((p) && (p.x >= x0) && (p.x < x3) && (p.y >= y0) && (p.y < y3)) {

                        if (subPixel) {
                            subPts.push(p.all);
                        }
                        else {
                            if (p.all.group) {
                                delete (p.all.group);
                            }
                            pts.push(p.all);
                        }

                    }
                    // if quad rect is outside of the search rect do nto search in sub nodes (returns true)
                    return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
                });
                console.log(" Number of removed  points: " + counter);
                var newPts = [];
                if (Environment.isMobile() && pts.length > 5000) {
                    for (var i = 0; i < 5000; i++){
                        selectedPts = newPts.length + 1;
                        index = Math.floor(Math.random()*(pts.length - selectedPts));
                        pt = pts[index];
                        newPts.push(pt);
                        pts[index] = pts[pts.length - selectedPts];
                        pts[pts.length - selectedPts] = pt;
                    }
                    pts = newPts;
                }
                return pts;

            }

         
            function updateNodes(quadtree) {
                var nodes = [];
                quadtree.depth = 0; // root

                quadtree.visit(function (node, x1, y1, x2, y2) {
                    var nodeRect = {
                        left: MercatorXofLongitude(x1),
                        right: MercatorXofLongitude(x2),
                        bottom: MercatorYofLatitude(y1),
                        top: MercatorYofLatitude(y2),
                    }
                    node.width = (nodeRect.right - nodeRect.left);
                    node.height = (nodeRect.top - nodeRect.bottom);

                    if (node.depth == 0) {
                        console.log(" width: " + node.width + "height: " + node.height);
                    }
                    nodes.push(node);
                    for (var i = 0; i < 4; i++) {
                        if (node.nodes[i]) node.nodes[i].depth = node.depth + 1;
                    }
                });
                return nodes;
            }

            //-------------------------------------------------------------------------------------
            MercatorXofLongitude = function (lon) {
                return lon * 20037508.34 / 180;
            }

            MercatorYofLatitude = function (lat) {
                return (Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180)) * 20037508.34 / 180;
            }


            // Use Leaflet to implement a D3 geometric transformation.
            function projectPoint(x, y) {
                var point = leafletMap.latLngToLayerPoint(new L.LatLng(y, x));
                this.stream.point(point.x, point.y);
            }

            var transform = d3.geo.transform({ point: projectPoint });
            var path = d3.geo.path().projection(transform);


            updateNodes(qtree);

            leafletMap.on('moveend', mapmove);

            mapmove();




            function getZoomScale() {
                var mapWidth = leafletMap.getSize().x;
                var bounds = leafletMap.getBounds();
                var planarWidth = MercatorXofLongitude(bounds.getEast()) - MercatorXofLongitude(bounds.getWest());
                var zoomScale = mapWidth / planarWidth;
                return zoomScale;

            }

            function redrawSubset(subset) {
//                path.pointRadius(3);// * scale);
                var pointSize = Math.max(leafletMap.getZoom() - 6.0, 60/Math.max(5.0, numPoints), 0.6);// * 5 / Math.min(5, numPoints - 2);
                path.pointRadius(pointSize);


                var bounds = path.bounds({ type: "FeatureCollection", features: subset });
                var topLeft = bounds[0];
                topLeft[0] = topLeft[0] - 20;
                topLeft[1] = topLeft[1] - 20;
                var bottomRight = bounds[1];
                bottomRight[0] = bottomRight[0] + 20;
                bottomRight[1] = bottomRight[1] + 20;


                svg.attr("width", bottomRight[0] - topLeft[0])
                  .attr("height", bottomRight[1] - topLeft[1])
                  .style("left", topLeft[0] + "px")
                  .style("top", topLeft[1] + "px");
                
//                alert(svg.attr());


                g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

                var start = new Date();


                var points = g.selectAll("path")
                              .data(subset, function (d) {
                                  if (d.time < slider.value()) {
                                      return d.id;
                                  }
                              });
                points.enter().append("path");
                points.exit().remove();
                points.attr("d", path);

                points.style("fill-opacity", function (d) {
                    if (d.group) {
                        return (d.group * 0.1) + 0.2;
                    }
                });
//                d3.select("#slider").selectAll("text").attr("fill", "#FF5252");

//                console.log("updated at  " + new Date().setTime(new Date().getTime() - start.getTime()) + " ms ");

            }
            var subset;
            function mapmove(e) {
                var mapBounds = leafletMap.getBounds();
                subset = search(qtree, mapBounds.getWest(), mapBounds.getSouth(), mapBounds.getEast(), mapBounds.getNorth());
                console.log("subset: " + subset.length);

                redrawSubset(subset);

            }
                slider.on("slide", function(evt, value) {
                    var points = g.selectAll("path")
                                  .data(subset, function (d) {
                                      if (d.time < slider.value()) {
                                          return d.id;
                                      }
                                  });
                    points.enter().append("path");
                    points.exit().remove();
                    points.attr("d", path);
                });


        });

    </script>
</body>
</html>