<!doctype html>
<html>
<head>
    <title>Many Points with  leaflet WebGL</title>
    <meta charset="utf-8">

    <style>
        html, body {
            height: 100%;
            padding: 0;
            margin: 0;
            background: rgb(123, 31, 162);
            height: 100%;
            position: relative;
	    overflow: hidden;            
        }
        
        .axis text {
  font: 10px sans-serif;
}

.axis line,
.axis path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

        
        path {
            fill: #009688;   
//	    fill: #FF5252;
//	    fill: #3F51B5;
        }

	path:hover {
	    fill:#FF5252;
	}

        #map {
            position: absolute;
            height: 100%;
            width: 100%;
            background-color: #7b1fa2;
	    cursor: default;
        }
        
        #slider {
            width: 90%;
            margin-left: 5%;
            margin-right: 5%;
            margin-bottom: 20px;
            fill: #FF5252;
        }
        
        

/*        #timeline {
            position: absolute;
//            height: 100%;
            width: 100%;
            background-color: #7b1fa2;
        }*/
    </style>
</head>
<body>
    <div id="map"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css" />

    <script src="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js"></script>
 <script src="/static/L.CanvasOverlay.js"></script>
    <!--script src="http://www.sumbera.com/gist/js/leaflet/canvas/L.CanvasOverlay.js"></script-->
    <script src="http://www.sumbera.com/gist/86T.json" charset="utf-8"></script>
    <link rel="stylesheet" type="text/css" href="/static/d3.slider.css" media="screen" />
    <script src="/static/d3.slider.js"></script>

    <div id="slider"></div>
    <script>

    var slider = d3.slider().axis(true).min(0).max(0).step(60);
        
    d3.select('#slider').call(slider);

    var Environment = {
        //mobile or desktop compatible event name, to be used with '.on' function
        TOUCH_DOWN_EVENT_NAME: 'mousedown touchstart',
        TOUCH_UP_EVENT_NAME: 'mouseup touchend',
        TOUCH_MOVE_EVENT_NAME: 'mousemove touchmove',
        TOUCH_DOUBLE_TAB_EVENT_NAME: 'dblclick dbltap',

        isAndroid: function() {
            return navigator.userAgent.match(/Android/i);
        },
        isBlackBerry: function() {
            return navigator.userAgent.match(/BlackBerry/i);
        },
        isIOS: function() {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i);
        },
        isOpera: function() {
            return navigator.userAgent.match(/Opera Mini/i);
        },
        isWindows: function() {
            return navigator.userAgent.match(/IEMobile/i);
        },
        isMobile: function() {
            return (Environment.isAndroid() || Environment.isBlackBerry() || Environment.isIOS() || Environment.isOpera() || Environment.isWindows());
        }
    };
function getParameterByName(name) {
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}

        var lat = getParameterByName('lat');
        lat = (lat == "") ? "42.3601" : lat;
        var lon = getParameterByName('lon');
        lon = (lon == "") ? "-71.0589" : lon;        

function setPosition(position) {
	lat = position.coords.latitude;	
	lon = position.coords.longitude;
	leafletMap.setView([lat, lon], 16);
}

    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(setPosition);
    }

            var cscale = d3.scale.linear().domain([1, 3]).range(["#ff0000", "#ff6a00", "#ffd800", "#b6ff00", "#00ffff", "#0094ff"]);//"#00FF00","#FFA500"
            var leafletMap = L.map('map').setView([lat, lon], 16);

            leafletMap.setZoom(16);
//            L.tileLayer("http://{s}.sm.mapstack.stamen.com/(toner-lite,$fff[difference],$fff[@23],$fff[hsl-saturation@20])/{z}/{x}/{y}.png").addTo(leafletMap);
            L.tileLayer("http://{s}.sm.mapstack.stamen.com/($7b1fa2[@p],toner-lite[soft-light],$ff5252[difference@p],$ff0000[hsl-saturation@p])/{z}/{x}/{y}.png", {
	noWrap:true
}).addTo(leafletMap);
       
 
        d3.csv('/static/testDataCZ.csv', function (error, incidents) {

            function reformat(array) {
                var data = [];
                array.map(function (d, i) {
                    data.push({
                        id: i,
                        type: "Feature",
                        geometry: {
                            coordinates: [+d.longitude, +d.latitude],
                            type: "Point"
                        },
                        time: d.time                     

                    });
                });
                return data;
            }
            var geoData = { type: "FeatureCollection", features: reformat(incidents) };
//         console.log(geoData);   
            var numPoints = incidents.length;

            var qtree = d3.geom.quadtree(geoData.features.map(function (data, i) {
                return {
                    x: data.geometry.coordinates[0],
                    y: data.geometry.coordinates[1],
                    all: data
                };
            }));


            // Find the nodes within the specified rectangle.
            function search(quadtree, x0, y0, x3, y3) {
                var pts = [];
                var subPixel = false;
                var subPts = [];
                var scale = getZoomScale();
                console.log(" scale: " + scale);
                var counter = 0;
                quadtree.visit(function (node, x1, y1, x2, y2) {
                    var p = node.point;
                    var pwidth = node.width * scale;
                    var pheight = node.height * scale;

                    // -- if this is too small rectangle only count the branch and set opacity
                    if ((pwidth * pheight) <= 1) {
                        // start collecting sub Pixel points
                        subPixel = true;
                    }
                        // -- jumped to super node large than 1 pixel
                    else {
                        // end collecting sub Pixel points
                        if (subPixel && subPts && subPts.length > 0) {

                            subPts[0].group = subPts.length;
//                            alert(subPts.length);
                            pts.push(subPts[0]); // add only one todo calculate intensity
                            counter += subPts.length - 1;
                            subPts = [];
                        }
                        subPixel = false;
                    }

                    if ((p) && (p.x >= x0) && (p.x < x3) && (p.y >= y0) && (p.y < y3)) {

                        if (subPixel) {
                            subPts.push(p.all);
                        }
                        else {
                            if (p.all.group) {
                                delete (p.all.group);
                            }
                            pts.push(p.all);
                        }

                    }
                    // if quad rect is outside of the search rect do nto search in sub nodes (returns true)
                    return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
                });
                console.log(" Number of removed  points: " + counter);
                var newPts = [];
/*                if (Environment.isMobile() && pts.length > 5000) {
                    for (var i = 0; i < 5000; i++){
                        selectedPts = newPts.length + 1;
                        index = Math.floor(Math.random()*(pts.length - selectedPts));
                        pt = pts[index];
                        newPts.push(pt);
                        pts[index] = pts[pts.length - selectedPts];
                        pts[pts.length - selectedPts] = pt;
                    }
                    pts = newPts;
                }*/
                return pts;

            }

         
            function updateNodes(quadtree) {
                var nodes = [];
                quadtree.depth = 0; // root

                quadtree.visit(function (node, x1, y1, x2, y2) {
                    var nodeRect = {
                        left: MercatorXofLongitude(x1),
                        right: MercatorXofLongitude(x2),
                        bottom: MercatorYofLatitude(y1),
                        top: MercatorYofLatitude(y2),
                    }
                    node.width = (nodeRect.right - nodeRect.left);
                    node.height = (nodeRect.top - nodeRect.bottom);

                    if (node.depth == 0) {
                        console.log(" width: " + node.width + "height: " + node.height);
                    }
                    nodes.push(node);
                    for (var i = 0; i < 4; i++) {
                        if (node.nodes[i]) node.nodes[i].depth = node.depth + 1;
                    }
                });
                return nodes;
            }

            //-------------------------------------------------------------------------------------
            MercatorXofLongitude = function (lon) {
                return lon * 20037508.34 / 180;
            }

            MercatorYofLatitude = function (lat) {
                return (Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180)) * 20037508.34 / 180;
            }

            updateNodes(qtree);
	
        var canvasOverlay = L.canvasOverlay()
            .drawing(drawingOnCanvas)
            .addTo(leafletMap);

//alert(leafletMap.canvasOverlay());

function redrawInBounds(x0, y0, x1, y1) {

	    var mapZoom = leafletMap.getZoom();
            subset = search(qtree, x0, y0, x1, y1);
//console.log(canvasOverlay._map.layerPointToLatLng([prevDot.x, prevDot.y]));
//console.log(x0, y0, x1, y1);
//console.log(subset.length);
            var ctx = canvasOverlay.canvas().getContext('2d');
            for (var i = 0; i < subset.length; i++) {
                var d = subset[i];
//		console.log(d);
		newDot = canvasOverlay._map.latLngToContainerPoint([d.geometry.coordinates[1], d.geometry.coordinates[0]]);
		ctx.fillStyle = "#009688";
                ctx.beginPath();
//                console.log("NEW DOT", newDot);
		ctx.arc(newDot.x, newDot.y,  Math.min(5*mapZoom/20, 5), 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            }
}

var prevDot = {x:-1, y:-1};

       leafletMap.on('mousemove', function(e) {
                var lon = e.latlng.lng;
                var lat = e.latlng.lat;
                var pt = qtree.find([lon, lat]);
//	console.log(pt);
//         alert(qtree.find([lon, lat]));
//console.log(prevDot);
            var ctx = canvasOverlay.canvas().getContext('2d');
//            ctx.fillStyle = "rgba(255,116,0, 1)";
            selDot = canvasOverlay._map.latLngToContainerPoint([pt.all.geometry.coordinates[1], pt.all.geometry.coordinates[0]]);
            ctx.clearRect(prevDot.x - 5, prevDot.y - 5, 10, 10);
	    refillTopRight = canvasOverlay._map.containerPointToLatLng([prevDot.x-6, prevDot.y-6]);
            refillBottomLeft = canvasOverlay._map.containerPointToLatLng([prevDot.x+6, prevDot.y+6]);
	    redrawInBounds(refillTopRight.lng, refillBottomLeft.lat, refillBottomLeft.lng, refillTopRight.lat); 
//	   console.log("DOT", dot); 
	    prevDot = {x:selDot.x, y:selDot.y};

            ctx.fillStyle = "rgba(255,116,0, 1)";
            ctx.beginPath();
            ctx.arc(selDot.x, selDot.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

        });


            function getZoomScale() {
                var mapWidth = leafletMap.getSize().x;
                var bounds = leafletMap.getBounds();
                var planarWidth = MercatorXofLongitude(bounds.getEast()) - MercatorXofLongitude(bounds.getWest());
                var zoomScale = mapWidth / planarWidth;
                return zoomScale;

            }


                var start = new Date();

//            }
            var subset;

	

        function drawingOnCanvas(canvasOverlay, params) {
//console.log(params);
		var mapZoom = leafletMap.getZoom();
                var mapBounds = leafletMap.getBounds();
                subset = search(qtree, mapBounds.getWest(), mapBounds.getSouth(), mapBounds.getEast(), mapBounds.getNorth());
console.log("MAP", mapBounds.getWest(), mapBounds.getSouth(), mapBounds.getEast(), mapBounds.getNorth());
            var ctx = params.canvas.getContext('2d');
            ctx.clearRect(0, 0, params.canvas.width, params.canvas.height);
//            ctx.fillStyle = "rgba(255,116,0, 0.2)";
	ctx.fillStyle = "#009688";
            for (var i = 0; i < subset.length; i++) {
                var d = subset[i];
//		console.log(d);
//                if (params.bounds.contains([d[0], d[1]])) {
                    dot = canvasOverlay._map.latLngToContainerPoint([d.geometry.coordinates[1], d.geometry.coordinates[0]]);
//dot =projectPoint(d.geometry.coordinates[0], d.geometry.coordinates[1]);
//		console.log(dot);
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, Math.min(5*mapZoom/20, 5), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
//                }
            }
        };


        });

    </script>
</body>
</html>
